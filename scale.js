'use strict';

// Transfrom

const canvas = document.querySelector('.canvas');
const context = canvas.getContext('2d'); 
let scaleValue = 1;

function draw(){
  context.clearRect(0, 0, canvas.width, canvas.height); 
  // 이거는 점점 커지는 애니메이션처럼 보이게 하려고 매 프레임을 지우고 시작하는거
  // 재밌는 게 이전 프레임에서 기준점 상태값을 restore를 하지 않았다면, 
  // 얘도 350, 350을 기준점으로 하게 되니, (0, 0) = (350, 350) 같은 게 되어버리는 거임.
  // strokeRect에서도 (-50, -50) = (300, 300)과 같은 것과 마찬가지 원리

  context.save();
  // 이거에는 clearRect의 기준점이 왼쪽 위가 (0, 0)이 되도록 한 것이 저장된 상태겠지? 

  context.setTransform(1, 0, 0, 1, 0, 0);
  /**
   * setTransform 함수는 변환함수를 그리기 위해서 가장 먼저 호출해야 하는 함수이다.
   * 이 함수의 주 목적은 canvas의 기본 확대, 경사도, 이동거리를 설정하기 위해 사용된다.
   * 
   * setTransform(a, b, c, d, e, f)
   * a : 수평으로 확대/축소율
   * b : 수직방향 경사율
   * c : 수평방향 경사율
   * d : 수직방향 확대/축소율
   * e : 수평방향 이동거리
   * f : 수직방향 이동거리
   * 
   * 2D의 평면상태
   * ctx.setTransform(1, 0, 0, 1, 0, 0);
   * 2D에서의 평면상태는 위와 같이
   * 확대하지 않은 상태에 경사도 없고 이동도 하지 않은 상태를 나타냄.
   * 
   * 변환을 초기화하는 메소드
   */

  // 그럼 어떻게 왼쪽 위인 기준점을 사각형 중앙으로 이동해줘야 하나? translate 메소드를 이용하면 됨!
  // translate(x, y) 이 메소드는 그리드에서 canvas를 원점에서 다른 점으로 옮기는 데 사용됨.
  // x는 이동시킬 수평 거리를 가리키고, y는 그리드에서 수직으로 얼마나 멀리 떨어지는지를 표시함.
  // 변형하기 전에 canvas 상태를 저장하는 것이 좋다. (save를 이용해서!)
  // 대다수의 경우, 원래 상태로 되돌리려고 역이동(reverse translation)을 시키는 것보다 restore 메소드를 호출하는 것이 더욱 간편합니다.
  // 그니까 다시 translate(-350, -350);하는 것보다, 그냥 (0, 0)을 처음에 저장해놓고 restore해서 원점 위치 복구하는 게 더 편하다고.
  
  // 어쨋든 내가 300, 300 위치에 사각형을 그리고 싶다면, 그 사각형의 중심점은 350, 350이니까 
  // translate을 이용해서 기준점을 (0, 0) -> (350, 350)으로 옮긴 것.
  context.translate(350, 350);

  // scale(x, y)
  // canvas 단위를 수평으로 x만큼, 수직으로 y만큼 크기를 확대·축소. 둘의 매개 변수는 실수.
  // 1.0보다 작은 값이면 단위 크기(1px)를 축소, 1.0보다 큰 값이면 단위 크기를 확대, 값이 1.0이면 단위 크기는 그대로
  // 기본적으로 canvas에서 하나의 단위는 정확히 1px
  // 예를 들어, 0.5라는 확대·축소 비율을 적용한다면, 결과로 나오는 단위는 0.5 픽셀이 됨. 고로 모양도 절반 크기로 그려짐.
  context.scale(scaleValue, scaleValue);
  scaleValue += 0.1; // 이렇게 프레임마다 단위 크기를 늘려나갈 예정임. 1.1배, 1.2배, ... 

  // 근데 왜 scale이 늘어나는데 css처럼 가운데 점을 중심으로 늘어나는 게 아니라 오른쪽 아래로 쳐지면서 늘어나지?
  // 그 이유는, 캔버스는 무조건 왼쪽 위가 기준임. 
  // css처럼 고수준의 api가 아니기 때문에, 캔버스는 자동으로 도형의 센터를 알아서 잡아주는 게 없음.
  // 무조건 디폴트인 왼쪽 위를 기준으로 변형이 되기 때문에 이걸 우리가 원하는 대로 만드려면
  // 먼저 기준으로 삼을 점의 위치까지 이동을 시킨 다음, 회전을 해주든 크기를 늘리든 해야하는 것.
  // 기준점도 직접 잡아줘야 하는거임. 그래서 캔버스가 저수준이라는 거

  context.strokeRect(-50, -50, 100, 100); // stroked rectangle이 그려짐. strokeStyle()로 색상값 설정 가능
  // 이제 이렇게 하면 맨 처음 그려지는 사각형은 (350, 350) 위치를 기준점으로 -50, -50 했으니까
  // (300, 300) 위치에 100, 100 사이즈로 그려지겠지?
  // 그리고 나서 다음 프레임에서도 1.01배로 키운 사각형이 똑같이 (300, 300) 위치에 그려지겠지만,
  // 원래 그리던 사각형의 1.01배가 커진거니까, 같은 중심점에서 원래 사각형보다 1.01배 커진 사각형이 그려질거임.
  // 위치는 같지만, 같은 위치상에서 크기(scale)만 커지는 사각형이 그려지기 때문에 중심점은 같고, 그 중심점에서 방사형으로 퍼지는 모양이 나오는 것.
  
  /**
   * 그럼 계속 (300, 300)자리에서 그려져야지 왜 방사형으로 퍼지냐?
   * 그렇게 따지면 width와 height값도 100, 100으로 고정되서 그려져야지 왜 자꾸 1.1배, 1.2배로 커지냐? 라고 할수도 있음.
   * scale이라는 것은 말했듯이 '단위 크기'를 축소하는 개념이라는거야.
   * 
   * 이게 뭔 말이냐면, strokeRect는 항상 원점 (350, 350)이 (0, 0)이라고 가정할 때를 기준으로
   * (-50, -50) 위치에 (100, 100) 사이즈의 사각형을 프레임마다 똑같이 그리는건 맞음.
   * 그치만! 저 -50, 100 이 숫자들의 단위가 1 -> 1.1 -> 1.2 -> 1,3 -> ... 이런식으로 프레임마다 '단위'가 늘어나는 거지.
   * 그래서 '실제로는' 두 번째 프레임은 (-50 * 1.1px, -50 * 1.1px, 100 * 1.1px, 100 * 1.1px) 이 위치와 사이즈로 그려지는거임
   * 그니까 사각형이 1.1만큼 왼쪽 위로 올라간 위치에서 시작해서, 1.1만큼 width와 height이 커진 사각형으로 그려지는 거지
   * 
   * 매번 프레임마다 똑같은 위치에, 똑같은 사이즈로 사각형을 그리는것 같지만, 
   * scale에 의해서 단위크기가 매 프레임마다 달라지기 때문에, '실제로는' 다른 위치, 다른 사이즈로 그려지는 것이다! 
   */

  context.restore();
  // 얘는 translate에서 이동한 기준점의 위치를 다시 원래 왼쪽 위의 (0, 0)으로 복구해놓은 것. 
  // 그래야 다음 프레임을 그리기 전 clearRect에서 0, 0 위치에서 시작해서 canvas의 사이즈만큼 제대로 지워질테니까.

  context.fillRect(10, 10, 30, 30);
  // restore로 원래 왼쪽 위 (0, 0)으로 기준점을 복구해놨기 때문에 (360, 360)자리가 아니라 (10, 10) 자리에 작은 사각형을 계속 그리게 됨.

  requestAnimationFrame(draw); // transform으로 변형되는 걸 보여주려고 애니메이션으로 만든 것.
}

draw();
