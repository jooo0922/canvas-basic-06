'use strict';

// scale에 Rotation도 추가해보자
// 회전을 시키려면 각도가 변해야겠지?
// 그래서 0도부터 1도씩 늘려서 회전하는 걸 만들어볼 것이다.

const canvas = document.querySelector('.canvas');
const context = canvas.getContext('2d'); 
let scaleValue = 1;
let rotationValue = 0; // 이게 0도에서 360도까지 늘어나면 한 바퀴 도는거겠지?

function toRadian(d){
  // 360도 기반의 각도 단위를 라디안값으로 변환하는 함수
  return d * Math.PI / 180;
}

function draw(){
  // context.clearRect(0, 0, canvas.width, canvas.height); 
  // 그리고 애니메이션 만들 때 clearRect()를 안해줘도 의외의 멋진 효과들이 꽤 많이 나옴.
  // rotation과 scale을 섞어 쓴 상태에서 프레임을 안지우고 애니메이션을 주면 다른 거로는 구현하기 어려운 멋진 효과가 꽤 많음.
  // 의외의 이런 예술적인 효과들이 많을 수 있으니 이런 것들도 직접 만들어보면서 조금씩 조정해볼것

  context.save();

  context.setTransform(1, 0, 0, 1, 0, 0);
  // 지금은 예제가 단순해서 크게 의미가 없을 수 있지만 setTransform()이 뭐하는 애냐면
  //  '변환'을 '초기화' 하는 것.
  // context.setTransform(1, 0, 0, 1, 0, 0); = context.resetTransform() 이렇게 써도 똑같은거임.
  // 디폴트로 변환하기 전에 쓰는거라 크게 신경은 안써도 되겠지만
  // 나중에 캔버스로 변환을 다루다보면 더 복잡한 움직임에 대한 욕심이 생기게 된다.
  // 복잡한 transform을 사용할 때, scale, rotate 요런걸로 깔짝대기 어려우니까
  // '행렬' 개념을 사용해서 복잡한 transform을 만들어낼 때 사용함. (1, 0, 0, 1, 0, 0) 이게 지금 행렬임.
  // 왜 행렬을 이용할까요? MDN에서 행렬로 이용하는 게 편하다고 함. 그래서 행렬을 쓴다고 함.
  // 행렬을 안쓰는 방법도 있다고 하는데 그거는 훨씬 어렵다고 함. 알 필요도 없고, 그거에 대한 메소드도 없고...
  // 나중에 캔버스로 복잡한 변환을 더 해보고 싶으면 행렬을 공부해보라고 함...
  // 평행이동, 회전, 스케일 변환 등을 행렬로 만들 수 있다고 함...

  /**
   * 행렬에 대한 설명
   * 
   * 단위 행렬: (1, 0, 0, 1, 0, 0) 이런 거를 단위행렬 이라고 함.
   * 이게 뭐냐면 어떤 애가 되었던 간에, 단위 행렬을 곱했을 때는 값의 변화가 없음!
   * 그니까 정수로 치면, 4 * 1 = 4, 5 * 1 = 5, 6 * 1 = 6 에서 1에다가 뭐를 곱하던 값의 변화가 없지?
   * 단위행렬은 행렬에서 1같은 존재라고 보면 됨.
   * 
   * 굳이 이런걸 알아야되나 생각하지 말고 캔버스를 깊게 사용하려면 꼭 필요한 개념이니 알아둘 것.
   * 캔버스가 확실히 다루기 어려운 게 코딩의 양도 많지만 뭐 하나를 하려고 해도 계산을 직접 해줘야 되는거...
   * 프레임을 지우고 다시 그리고 이런 것들도 다 직접 해줘야 됨...
   * 
   * 그래서 코딩의 양이 많고 까다롭지만 할 수 있는 것들이 무궁무진하게 많기도 함.
   * 사람들이 '오!' 할만큼 감탄사가 나올만한 것들은 전부 캔버스로 만들었다고 봐도 됨.
   * 
   * d3.js 같은 라이브러리를 쓴다고 해도 캔버스가 필요한 순간이 있음.
   * 데이터 시각화도 내가 원하는대로 하려면 캔버스에서 했듯이 수학적 계산, 수학공부를 해줘야 함.
   * 
   * 지금 이런 것들은 canvas 2d api니까 라이브러리 도움 없이도 캔버스에서 간단한 수학 계산으로도 가능한건데
   * 3d를 만들려면 webGl이라는 걸 사용해야 됨. 이거는 너무 어려워서 아무나 할 수가 없는거고ㅠ
   * 그래서 보통 webGl은 이런 쌩짜로 계산하는 게 너무 어렵기 때문에 three.js같은 라이브러리의 도움을 많이 받는거임..
   * 
   * 그래서 오히려 3d 같은거는 라이브러리만 잘 공부해두면 수학계산같은 게 많이 필요없을 경우가 많음.
   * 오히려 지금 하는거보다 코딩이 쉬울 수 있음. 지금 하는거는 라이브러리 도움 없이 쌩짜로 수학계산을 하는거니까...
   * 3d는 못하겠네 하면서 너무 겁먹지 말 것.. 그래서 캔버스로 굳이 어렵게 3d 만들려고 하지 말고 라이브러리 쓸 것.
   * 근데 그런 라이브러리를 쓰려고 해도 지금 하는 기본적인 캔버스 사용법은 공부해둬야 함!
   * 그래서 캔버스 안하고 three.js 공부하는거는 자바스크립트 안하고 라이브러리부터 공부하는 느낌이라고 함.
   * 
   * 그래서 기본적인 쉬운 수학 공부는 해두는게 좋다. 삼각함수, 행렬, 벡터 정도...
   * 문과여도 하면 다 된다고 하네..ㅠ
   */

  context.translate(350, 350);

  context.scale(scaleValue, scaleValue);
  context.rotate(toRadian(rotationValue)); 
  // 회전을 추가할때는 rotate로 할 것
  // 근데 주의할 점!
  // rotation에서 각도 parameter를 전달할때는 여기서도 라디안 값을 사용해야 함!
  // 그래서 360도 기반의 각도 단위를 라디안값으로 변환하는 함수(toRadian)를 만들어줘서 사용해야 함!

  context.strokeRect(-50, -50, 100, 100); 
  // 자주 할 수 있는 실수.
  // 사각형이나 패스를 위에 그려놓고 scale, rotate, translate 등 transform 을 그 다음에 해줬을 때
  // 이거는 그냥 원래 캔버스 상태에서 사각형을 찍어놓고 그 밑에서 열씸히 변환하는 거.
  // 그니까 아무것도 안한 사각형만 프레임에 찍어놓고 그 밑에서 사각형 transform 열심히 해줘놓고 프레임에는 안찍음
  // 그러면 변환된 사각형이 안보이니까 당연히 transform이 안되는 것처럼 보이겠지?

  context.setTransform(1, 0, 0, 1, 0, 0); 
  context.fillRect(10, 10, 30, 30); 
  // 이런데서 setTransform(1, 0, 0, 1, 0, 0) 얘가 필요한거임.
  // 지금 fillRect() 작은 사각형을 restore하기 전에 호출함으로써 
  // strokeRect랑 똑같은 transform 애니메이션이 적용되고 있음. 우리가 strokeRect에 줄려고 만든 transform을 얘도 먹는 거.
  // 원래는 왼쪽 위에 쪼그만 상태로 가만히 있어야 될 애인데 restore으로 기본값이 복구되기 이전에 호출되버려서 이렇게 된거임.
  // 근데 이 상태에서 setTransform(1, 0, 0, 1, 0, 0) 이걸 써주면 원래 의도했던 상태로 돌아가게 됨.
  // '변환'(윗줄에 사용된 translate, scale, rotate 얘내들)을 '초기화'해준 것. 단위 행렬로! 

  //  MDN에서는 좀 어려운 말로 '현재 변형 상태를 단위 행렬로 재설정하고 나서 동일한 인수로 transform() 메소드를 적용함' 이라고 표현함.
  // 그니까 현재의 transform 상태를 단위 행렬, 즉 (1, 0, 0, 1, 0, 0)로 초기화한다는 뜻이지.
  // restore()랑 역할이 비슷함. 그니까 restore를 못하는 상황이면 저걸 대신 써도 되고, 그냥 restore를 써도 되는거.

  // 근데 뭘로 하든간에! 'transform의 초기화'를 '버릇처럼' 해주고 나서 다음 프레임으로 넘어가거나, 변환을 시작하기 전에 초기화를 해줄 것!!
  // 이게 버릇이 안되면 나중에 복잡해지면서 코딩이 꼬이면 왜 안되는지 파악도 안되고 답 안나옴.

  context.restore();

  scaleValue += 0.05; 
  rotationValue += 1; // rotation은 1도씩 늘려서 돌아가게 할 거임.

  

  requestAnimationFrame(draw); 
}

draw();
